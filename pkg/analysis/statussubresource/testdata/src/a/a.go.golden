package a

// +kubebuilder:object:root:=true
type Foo struct {
	Spec FooSpec `json:"spec"`
}

type FooSpec struct {
	Name string `json:"name"`
}

// +kubebuilder:object:root:=true
// +kubebuilder:subresource:status
type Bar struct { // want "root object type \"Bar\" is marked to enable the status subresource with marker \"kubebuilder:subresource:status\" but has no status field"
	Spec BarSpec `json:"spec"`
}

type BarSpec struct {
	Name string `json:"name"`
}

// +kubebuilder:object:root:=true
// +kubebuilder:subresource:status
type Baz struct { // want "root object type \"Baz\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	Spec   BazSpec   `json:"spec"`
	Status BazStatus `json:"status,omitempty"`
}

type BazSpec struct {
	Name string `json:"name"`
}

type BazStatus struct {
	Name string `json:"name"`
}

// +kubebuilder:object:root:=true
// +kubebuilder:subresource:status
type FooBar struct {
	Spec   FooBarSpec   `json:"spec"`
	Status FooBarStatus `json:"status"`
}

type FooBarSpec struct {
	Name string `json:"name"`
}

type FooBarStatus struct {
	Name string `json:"name"`
}

// Test that it works with 'root=true' as well
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type FooBarBaz struct { // want "root object type \"FooBarBaz\" is marked to enable the status subresource with marker \"kubebuilder:subresource:status\" but has no status field"
	Spec FooBarBazSpec `json:"spec"`
}

type FooBarBazSpec struct {
	Name string `json:"name"`
}

// Test that List types are skipped (issue #53)
// This is a Kubernetes List type with TypeMeta, ListMeta, and Items
// Even with space between marker and type definition, it should be skipped

// +kubebuilder:object:root=true
type ClusterList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
	Items    []Cluster `json:"items"`
}

// Test marker detection with blank line (second level comment bug - issue #53)
// +kubebuilder:object:root=true

// ServiceList contains a list of Service.
type ServiceList struct {
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
	Items    []Service `json:"items"`
}

type Service struct {
	Name string `json:"name"`
}

type TypeMeta struct {
	Kind       string `json:"kind,omitempty"`
	APIVersion string `json:"apiVersion,omitempty"`
}

type ListMeta struct {
	ResourceVersion string `json:"resourceVersion,omitempty"`
}

type Cluster struct {
	Name string `json:"name"`
}

// Test List type with qualified types (metav1.TypeMeta, metav1.ListMeta)
// +kubebuilder:object:root=true
type PodList struct {
	metav1TypeMeta `json:",inline"`
	metav1ListMeta `json:"metadata,omitempty"`
	Items          []Pod `json:"items"`
}

type metav1TypeMeta struct {
	Kind       string `json:"kind,omitempty"`
	APIVersion string `json:"apiVersion,omitempty"`
}

type metav1ListMeta struct {
	ResourceVersion string `json:"resourceVersion,omitempty"`
}

type Pod struct {
	Name string `json:"name"`
}

// Test that non-List types are not skipped even if they have 3 fields
// This should trigger the linter because it has a status field but no marker
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type NotAList struct { // want "root object type \"NotAList\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	Spec   NotAListSpec   `json:"spec"`
	Status NotAListStatus `json:"status"`
	Extra  string         `json:"extra"`
}

type NotAListSpec struct {
	Name string `json:"name"`
}

type NotAListStatus struct {
	Ready bool `json:"ready"`
}

// Test that types ending with "List" but not matching the pattern are not skipped
// This has 4 fields instead of 3, so it should not be treated as a List type
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type BadList struct { // want "root object type \"BadList\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
	Items    []string      `json:"items"`
	Status   BadListStatus `json:"status"`
}

type BadListStatus struct {
	Count int `json:"count"`
}

// Test that types ending with "List" but missing Items field are not skipped
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type IncompleteList struct { // want "root object type \"IncompleteList\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
	Status   IncompleteListStatus `json:"status"`
}

type IncompleteListStatus struct {
	Ready bool `json:"ready"`
}

// Test that types ending with "List" but with non-slice Items field are not skipped
// Items must be a slice type to be considered a valid List type
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type NonSliceItemsList struct { // want "root object type \"NonSliceItemsList\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
	Items    string         `json:"items"`
	Status   NonSliceStatus `json:"status"`
}

type NonSliceStatus struct {
	Count int `json:"count"`
}

// Test that List types with fields in non-standard order are still recognized
// Fields can be in any order as long as they have TypeMeta, ListMeta, and Items
// +kubebuilder:object:root=true
type ReorderedFieldsList struct {
	Items    []ReorderedItem `json:"items"`
	TypeMeta `json:",inline"`
	ListMeta `json:"metadata,omitempty"`
}

type ReorderedItem struct {
	Name string `json:"name"`
}

// Test marker detection with blank line for non-List type (second level comment bug - issue #53)
// This should trigger the linter because it has a status field but no status marker
// +kubebuilder:object:root=true

// BlankLineTest demonstrates marker detection across blank lines.
// +kubebuilder:subresource:status
type BlankLineTest struct { // want "root object type \"BlankLineTest\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	Spec   BlankLineTestSpec   `json:"spec"`
	Status BlankLineTestStatus `json:"status"`
}

type BlankLineTestSpec struct {
	Name string `json:"name"`
}

type BlankLineTestStatus struct {
	Ready bool `json:"ready"`
}

// Test case: Single-line marker separated by blank line should be detected as orphaned.
// This verifies that single-line markers with blank lines are properly detected.

// +kubebuilder:object:root=true

// SingleLineMarkerTest demonstrates that single-line markers separated by blank lines
// are detected as orphaned markers.
// This type has a status field but no status marker, so it should trigger a diagnostic.
// +kubebuilder:subresource:status
type SingleLineMarkerTest struct { // want "root object type \"SingleLineMarkerTest\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	Spec   SingleLineMarkerTestSpec   `json:"spec"`
	Status SingleLineMarkerTestStatus `json:"status"`
}

type SingleLineMarkerTestSpec struct {
	Name string `json:"name"`
}

type SingleLineMarkerTestStatus struct {
	Ready bool `json:"ready"`
}

// Test case: Marker too far away (more than 3 lines) should NOT be detected.
// The orphaned markers below should be ignored because they're too far from the type declaration.

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status






// +kubebuilder:object:root=true
//
// TooFarAwayTest demonstrates that markers too far away are not detected.
// Since the orphaned markers above are not detected, this type only has +kubebuilder:object:root=true
// from its Doc comment group. It has a status field but no status marker, so it should trigger the linter.
// +kubebuilder:subresource:status
type TooFarAwayTest struct { // want "root object type \"TooFarAwayTest\" has a status field but does not have the marker \"kubebuilder:subresource:status\" to enable the status subresource"
	Spec   TooFarAwayTestSpec   `json:"spec"`
	Status TooFarAwayTestStatus `json:"status"`
}

type TooFarAwayTestSpec struct {
	Name string `json:"name"`
}

type TooFarAwayTestStatus struct {
	Ready bool `json:"ready"`
}

// Test case: Commented-out code should NOT be treated as markers.

// +kubebuilder:object:root=true
// func DoSomething() error {
//     return nil
// }

// CommentedCodeTest should not pick up the commented code above.
type CommentedCodeTest struct {
	Name string `json:"name"`
}

// Test case: Marker that's a Doc comment for another declaration should NOT be orphaned.

// +kubebuilder:object:root=true
type PreviousType struct {
	Name string `json:"name"`
}

// NotOrphanedTest should not get markers from PreviousType.
type NotOrphanedTest struct {
	Name string `json:"name"`
}
